//// This file was generated by Google Gemini

use egui::{color_picker, Color32, RichText, Slider};
use engine_api::Engine;

use crate::{SharedState, Window};

const FOG_OVERRIDE: &str = "fog_override";
const FOG_ENABLE: &str = "fog_enable";
const FOG_START: &str = "fog_start";
const FOG_END: &str = "fog_end";
const FOG_COLOR: &str = "fog_color";

const FOG_ENABLE_SKYBOX: &str = "fog_enableskybox";
const FOG_START_SKYBOX: &str = "fog_startskybox";
const FOG_END_SKYBOX: &str = "fog_endskybox";
const FOG_COLOR_SKYBOX: &str = "fog_colorskybox";

const R_FARZ: &str = "r_farz";
// -------------------------------------------------- \\

#[derive(Debug)]
pub struct FogWindow {
    is_open: bool,
}

impl Default for FogWindow {
    fn default() -> Self {
        Self { is_open: true }
    }
}

impl Window for FogWindow {
    fn name(&self) -> &'static str { "Better Fog GUI" }
    fn toggle(&mut self) { self.is_open = !self.is_open; }
    fn is_open(&self) -> bool { self.is_open }
    fn is_should_render(&self, shared_state: &SharedState, _engine: &Engine) -> bool { shared_state.is_overlay_focused }

    fn draw(&mut self, ctx: &egui::Context, _shared_state: &mut SharedState, engine: &Engine) {
        let client = engine.client();
        let cvar_system = engine.cvar_system();

        let is_cheats_enabled = cvar_system.find_var("sv_cheats").unwrap().get_int() > 0;
        let color = if is_cheats_enabled {
            egui::Color32::GRAY
        } else {
            egui::Color32::ORANGE
        };

        egui::Window::new(self.name())
            .open(&mut self.is_open)
            .resizable(true)
            .default_width(320.0)
            .show(ctx, |ui| { ui.add_enabled_ui(is_cheats_enabled, |ui| {
                // --- Main Switches ---
                ui.label( RichText::new("Requires sv_cheats 1").color(color) );
                draw_cvar_checkbox(engine, ui, FOG_OVERRIDE, "Fog Override");
                ui.separator();

                // --- Primary Fog Section ---
                ui.collapsing(RichText::new("Primary Fog").strong(), |ui| {
                    let grid_id = "primary_fog_grid";
                    draw_fog_section(ui, engine, grid_id, FOG_ENABLE, FOG_START, FOG_END, FOG_COLOR);
                });
                ui.separator();

                // --- Skybox Fog Section ---
                ui.collapsing(RichText::new("Skybox Fog").strong(), |ui| {
                    let grid_id = "skybox_fog_grid";
                    draw_fog_section(ui, engine, grid_id, FOG_ENABLE_SKYBOX, FOG_START_SKYBOX, FOG_END_SKYBOX, FOG_COLOR_SKYBOX);
                });
                ui.separator();

                // --- FarZ Section ---
                if let Some(cvar) = cvar_system.find_var(R_FARZ) {
                    let mut farz_val = cvar.get_float();
                    let mut farz_override = farz_val != -1.0;

                    if ui.checkbox(&mut farz_override, "FarZ Override").changed() {
                        let new_val = if farz_override { 10000.0 } else { -1.0 };
                        client.execute_client_cmd_unrestricted(&format!("{} {}", R_FARZ, new_val));
                    }

                    if farz_override {
                        if ui.add(Slider::new(&mut farz_val, 0.0..=16000.0).text("FarZ")).changed() {
                            client.execute_client_cmd_unrestricted(&format!("{} {}", R_FARZ, farz_val));
                        }
                    }
                }
            });
            });
    }
}


/// Helper function to draw a complete fog section
fn draw_fog_section(
    ui: &mut egui::Ui,
    engine: &Engine,
    grid_id: &str,
    enable_cvar: &str,
    start_cvar: &str,
    end_cvar: &str,
    color_cvar: &str,
) {
    let _cvar_system = engine.cvar_system();
    draw_cvar_checkbox(engine, ui, enable_cvar, "Enable");

    egui::Grid::new(grid_id)
        .num_columns(2)
        .spacing([40.0, 4.0])
        .striped(true)
        .show(ui, |ui| {
            // Start
            ui.label("Start:");
            draw_cvar_slider(engine, ui, start_cvar, -1000.0..=10000.0);
            ui.end_row();

            // End
            ui.label("End:");
            draw_cvar_slider(engine, ui, end_cvar, -1000.0..=16000.0);
            ui.end_row();

            // Color
            ui.label("Color:");
            draw_cvar_color_picker(engine, ui, color_cvar);
            ui.end_row();
        });
}


/// Draws a checkbox that reads and writes to a cvar (0 or 1)
fn draw_cvar_checkbox(engine: &Engine, ui: &mut egui::Ui, name: &str, label: &str) {
    let cvar_system = engine.cvar_system();
    let client = engine.client();

    if let Some(cvar) = cvar_system.find_var(name) {
        let mut is_checked = cvar.get_int() != 0;
        if ui.checkbox(&mut is_checked, label).changed() {
            let new_value = if is_checked { 1 } else { 0 };
            client.execute_client_cmd_unrestricted(&format!("{} {}", name, new_value));
        }
    } else {
        ui.colored_label(Color32::DARK_RED, format!("'{}' not found", name));
    }
}

/// Draws a slider that reads and writes to a cvar (float)
fn draw_cvar_slider(engine: &Engine, ui: &mut egui::Ui, name: &str, range: std::ops::RangeInclusive<f32>) {
    let cvar_system = engine.cvar_system();
    let client = engine.client();

    if let Some(cvar) = cvar_system.find_var(name) {
        let mut value = cvar.get_float();
        if ui.add(Slider::new(&mut value, range)).changed() {
            client.execute_client_cmd_unrestricted(&format!("{} {}", name, value));
        }
    } else {
        ui.add_enabled(false, Slider::new(&mut 0.0, range));
    }
}

/// Draws a color picker that reads and writes to a cvar (string "r g b")
fn draw_cvar_color_picker(engine: &Engine, ui: &mut egui::Ui, name: &str) {
    let cvar_system = engine.cvar_system();
    let client = engine.client();

    if let Some(cvar) = cvar_system.find_var(name) {
        let color_str = cvar.get_string();
        let parts: Vec<u8> = color_str.split_whitespace()
            .filter_map(|s| s.parse::<u8>().ok())
            .collect();

        let mut color = if parts.len() == 3 {
            Color32::from_rgb(parts[0], parts[1], parts[2])
        } else {
            Color32::BLACK
        };

        let response = color_picker::color_edit_button_srgba(ui, &mut color, color_picker::Alpha::Opaque);
        if response.changed() {
            let new_color_str = format!("{} {} {}", color.r(), color.g(), color.b());
            client.execute_client_cmd_unrestricted(&format!("{} \"{}\"", name, new_color_str));
        }

    }
}
